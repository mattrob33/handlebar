package dev.mattrobertson.handlebar.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.TypeParameterResolver
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName

/**
 * Generates an implementation of the interface generated by [TypedStateContractGenerator].
 */
internal class TypedStateImplGenerator(
    codeGenerator: CodeGenerator
): SingleTypeFileGenerator(codeGenerator) {

    fun generate(
        sourceInterface: ClassName,
        properties: List<TypedStateProperty>
    ) {
        val superName = "${sourceInterface.simpleName}Contract"
        val implName = "${sourceInterface.simpleName}ContractImpl"

        val implSpec = TypeSpec.classBuilder(implName).apply {
            properties.forEach { prop ->
                buildSpec(prop)
            }
        }
        .superclass(
            ClassName(
                packageName = "dev.mattrobertson.handlebar",
                "AbstractTypedState"
            )
        )
        .addSuperclassConstructorParameter("handle")
        .addSuperinterface(ClassName(sourceInterface.packageName, superName))
        .primaryConstructor(
            FunSpec.constructorBuilder()
                .addParameter("handle", ClassName("androidx.lifecycle", "SavedStateHandle"))
                .build()
        )
        .build()

        generateFile(
            packageName = sourceInterface.packageName,
            className = implName,
            typeSpec = implSpec
        )
    }

    /**
     * Builds the getter/setter for a property, as well as an update function for observable types.
     */
    private fun TypeSpec.Builder.buildSpec(prop: TypedStateProperty) {

        val isLiveData = (prop.type.toClassName().simpleName == "LiveData")

        addProperty(
            if (isLiveData)
                prop.buildLiveDataSpec()
            else
                prop.buildStandardSpec()
        )

        if (isLiveData) {
            addFunction(
                buildUpdateFunSpecForLiveDataProp(prop)
            )
        }
    }

    /**
     * Builds a [PropertySpec] for a non-observable property.
     */
    private fun TypedStateProperty.buildStandardSpec(): PropertySpec {

        val isNullable = type.toTypeName().isNullable

        return PropertySpec.builder(
            name,
            type.toTypeName(TypeParameterResolver.EMPTY),
            KModifier.OVERRIDE
        )
            .mutable(true)
            .getter(
                FunSpec.getterBuilder()
                    .addStatement(
                        "return handle[\"${name}\"]" +
                                if (isNullable)
                                    ""
                                else
                                    " ?: ${type.defaultValue}"
                    )
                    .build()
            )
            .setter(
                FunSpec.setterBuilder()
                    .addParameter("value", type.toTypeName(TypeParameterResolver.EMPTY))
                    .addStatement("handle[\"${name}\"] = value")
                    .build()
            )
            .build()
    }

    /**
     * Builds a [PropertySpec] for a LiveData property.
     */
    private fun TypedStateProperty.buildLiveDataSpec(): PropertySpec {
        val parameterizedType = type.arguments[0].type

        return PropertySpec.builder(
            name,
            type.toTypeName(TypeParameterResolver.EMPTY),
            KModifier.OVERRIDE
        )
            .mutable(false)
            .getter(
                FunSpec.getterBuilder()
                    .addStatement("return handle.getLiveData<${parameterizedType}>(\"${name}\", ${parameterizedType!!.resolve().defaultValue})")
                    .build()
            )
            .build()
    }

    /**
     * Builds a [FunSpec] for a function to update a LiveData property.
     */
    private fun buildUpdateFunSpecForLiveDataProp(prop: TypedStateProperty): FunSpec {
        val parameterizedType = prop.type.arguments[0].type

        return FunSpec.builder("update${prop.name.capitalize()}")
            .addModifiers(KModifier.OVERRIDE)
            .addParameter("value", parameterizedType!!.toTypeName())
            .addStatement("handle.getLiveData<${parameterizedType}>(\"${prop.name}\").value = `value`")
            .build()
    }
}