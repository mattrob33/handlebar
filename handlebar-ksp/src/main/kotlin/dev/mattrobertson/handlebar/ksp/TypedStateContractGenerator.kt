package dev.mattrobertson.handlebar.ksp

import com.google.devtools.ksp.processing.CodeGenerator
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName

/**
 * Generates the interface for the typed state. The actual implementation of this interface is
 * generated by [TypedStateImplGenerator].
 */
internal class TypedStateContractGenerator(
    codeGenerator: CodeGenerator
): SingleTypeFileGenerator(codeGenerator) {

    fun generate(
        sourceInterface: ClassName,
        properties: List<TypedStateProperty>
    ) {
        val interfaceName = "${sourceInterface.simpleName}Contract"

        val interfaceSpec = TypeSpec.interfaceBuilder(interfaceName).apply {
            properties.forEach {
                buildPropertySpec(it)
            }
        }
        .build()

        generateFile(
            packageName = sourceInterface.packageName,
            className = interfaceName,
            typeSpec = interfaceSpec
        )
    }

    private fun TypeSpec.Builder.buildPropertySpec(prop: TypedStateProperty) {
        val isLiveData = (prop.type.toClassName().simpleName == "LiveData")

        addProperty(
            PropertySpec.builder(prop.name, prop.type.toTypeName())
                .mutable(!isLiveData)
                .build()
        )

        if (isLiveData) {
            val parameterizedType = prop.type.arguments[0].type

            addFunction(
                FunSpec.builder("update${prop.name.capitalize()}")
                    .addParameter("value", parameterizedType!!.toTypeName())
                    .build()
            )
        }
    }


}